# 区分PATCH与PUT、POST方法 

2018-01-27 21:39

![img](http://5b0988e595225.cdn.sohucs.com/images/20180128/9a5647fee75f4b39a7dfa288fc707942.jpeg)

在HTTP原本的定义中[RFC2616]，用于上传数据的方法只有POST和PUT。后来鉴于POST和PUT语义和功能上的不足，又加入了PATCH方法[RFC5789]。POST与PUT方法的差异是显而易见的，而PUT与PATCH方法就比较相似，但它们的用法却完全不同。

PUT方法和PATCH方法所请求的目标地址都是直接指向资源的，而POST方法请求的目标是一个行为处理器，这点很容易区分。但PUT和PATCH呢？根据规范中所介绍的PUT用于替换资源，而PATCH用于更新部分资源。仅凭这个描述，我无法理解他们的区别，直到看到后面介绍PATCH是非幂等的时候才恍然大悟。

从这里开始要考虑一个问题，PATCH为什么是非幂等的呢？POST方法非幂等可以理解，因为它请求服务器执行一个动作，多次发起请求可能导致动作多次执行。而像PATCH这样请求的目标是一个资源的，如果它只是更新一个资源，不执行其它动作，又何来不幂等呢？其实是我忽略了一个问题，PATCH方法和POST方法有个很相似的地方，它们的实体部分都是结构化的数据。POST方法的实体结构一般是 **multipart/form-data**或 **application/x-www-form-urlencoded**而PATCH方法的实体结构则随其它规范定义。这和PUT方法的无结构实体相比就是最大的区别。

PUT方法的实体无结构的，它直接把实体部分的数据替换到服务器的资源上。而PATCH提供的实体则需要根据程序或其它协议的定义，解析后在服务器上执行，以此来修改服务器上的数据。也就是说，PATCH请求是会执行某个程序的，如果重复提交，程序可能执行多次，对服务器上的资源就可能造成额外的影响，这就可以解释它为什么是不幂等的了。

举个例子，如果服务器上有个资源/abc.int，里面存放一个整数，值为 **1**。也就是说，GET这个资源的话，服务器响应的实体只包含了 **1**这个数字。现在在自己的框架中定义当提交PATCH请求，实体匹配^+d+$的格式时就对服务器资源中的数字执行一个加法操作。于是当客户端向/abc.int地址发起PATCH请求，实体部分为+3之后，服务器的/abc.int资源中的数据就变成 **4**，也就是说，GET它会得到 **4**。如果客户端不小心重复提交了PATCH请求，那么+3就会被再执行一次，这个资源的数据就变成 **7**。

这么一看，PATCH和PUT的区别就非常明显了吧。

**总结：POST表示新增， PUT完整替换， PATCH部分替换。**
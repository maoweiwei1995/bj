0614vivo现场

1.垂直居中

## 2.position：有哪几样

| 值       | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| absolute | 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。 |
| fixed    | 生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。 |
| relative | 生成相对定位的元素，相对于其正常位置进行定位。因此，"left:20" **会向元素的 LEFT 位置添加 20 像素。** |
| static   | 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 |
| inherit  | **规定应该从父元素继承 position 属性的值。**                 |

## 3.三栏布局 中间自由 两侧固定宽度

## 4.协商缓存 强制缓存

如何实现

## 5.webpack作用

## 6.有没有自己的组件

## 7.拷贝数组

**slice**

```js
let arr = [2,4,434,43]
let arr1= arr.slice()
arr[0] = 'a'
console.log(arr,arr1) // [ 2, 4, 434, 43 ]
console.log(arr1 === arr) // false
```

遍历

```js
Array.prototype.clone = function(){
    let a=[];
    for(let i=0,l=this.length;i<l;i++) {
        a.push(this[i]);
    }
    return a;
}
let arr = ['aaa','bbb','ccc','wwwww','ddd']
let arr2 = arr.clone()
console.log(arr2)
console.log( arr2 === arr )
```

concat

```js
Array.prototype.clone=function(){ 
    return [].concat(this); 
    //或者 return this.concat();
}
let arr = ['aaa','asss']
let arr1 = arr.clone()
arr[0] = 123
console.log(arr,arr1)
```

object.assign

```js
let arr = ['sdsd',123,123,123]
let arr1 = []
Object.assign(arr1,arr)
arr[1] = 'aaaa'
console.log(arr,arr1) // [ 'sdsd', 'aaaa', 123, 123 ] [ 'sdsd', 123, 123, 123 ]
```

解构

```js
const a1 = [1, 2];
// 写法一
const a2 = [...a1];
a1[0] = 'aaa'
console.log(a1,a2)
```



## 8.数据类型 基本数据类型和引用数据类型 区别

# JS基本数据类型和引用数据类型的区别

**数据类型**

1. ECMAScript变量包含两种不同类型的值：基本类型值、引用类型值；
2. 基本类型值：指的是保存在**栈**内存中的简单数据段；
3. 引用类型值：指的是那些保存在**堆**内存中的对象，意思是，变量中保存的实际上只是一个指针，这个指针指向内存堆中实际的值；

**两种访问方式**

1. 基本类型值：**按值访问**，操作的是他们实际保存的值；

2. 引用类型值：

   按**引用访问**当查询时，我们需要先从**栈中读取内存地址**，然后再顺藤摸瓜地找到保存在堆内存中的值；

   

   ![img](https://upload-images.jianshu.io/upload_images/67090-a3fecb055ffebaf8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/484/format/webp)

**两种类型复制**
基本类型变量的复制：
从一个变量向一个变量复制时，**会在栈中创建一个新值**，然后把值复制到为新变量分配的位置上，**改变源数据不会影响到新的变量**（互不干涉）；
引用类型变量的复制：
**复制的是存储在栈中的指针**，将指针复制到栈中为新变量分配的空间中，而这个指针副本和原指针执行存储在堆中的同一个对象，复制操作结束后，两个变量实际上将引用同一个对象；因此**改变其中的一个，将影响另一个**；

**函数参数的传递**
**1、ECMA中所有函数的参数都是按值传递的**
在向参数传递基本类型的值时，被传递的值会被复制给一个**局部变量**，在向参数传递引用类型的值时，会把这个值在内存的地址复制给一个**局部变量**
基本数据类型传递参数

```js
　　funciton addTen(num){
　　　　num+=10;
　　　　return num;
　　}
　　var count=20;
　　var result=addTen(count);
　　alert(count);//20
　　alert(resullt);//30
```

执行结果是：20和30。
在这段代码中，将变量`count`当做参数传递给了函数`addTen`，也就是相当于将变量`count`的值复制给了函数`addTen`的参数。这时`addTen`的参数`num`可以看做是函数内部的一个变量。
在上段代码中，就相当于两个基本数据类型变量之间的值复制。而基本数据类型都有自己独立的内存地址，所以`num`和`count`是没有任何关系的，他们只是值相等而已，函数执行完毕后，`count`的值并没有改变。
而函数外面的`result`是被直接赋值的，所以`result`的值就是函数的结果30。

引用类型传递参数

```js
　　function setName(obj){
　　　　obj.name="LSN";
　　}
　　var person=new Object();
　　setName(person);
　　alert(person.name); // LSN
```

执行结果是：LSN。
在这段代码中，函数`setName`的作用是给`obj`对象添加了一个属性`name`，并给该属性赋值为"LSN"，因为`obj`是引用类型，所以这里属于是将引用类型`person`赋值给了`obj`，也就是说`person`和`obj`引用了一个内存地址，所以当给`obj`新加了属性`name`时，在函数外面的`person`也跟着改变，最后`person.name`的结果为LSN。

**引用类型传递参数到底传的是值还是引用**

```js
　　function setName(obj){
　　　　obj.name="ABC";
　　　　obj=new Object();
　　　　obj.name="BCD";
　　}
　　var person=new Object();
　　setName(person);
　　alert(person.name); // ABC
```

执行结果是：ABC。
实例3与实例2的区别是在函数中又加了2行代码，在给`obj`对象新加一个属性`name`并赋值后又将`obj`定义成了一个新的对象（`new Object()`），定义新对象后又`name`赋上新的值“BCD”。
这个时候如果是按引用传递的话，那么最后`person`对象就会自动修改为指向其`name`属性为"BCD"的新对象，但最后显示的却是“ABC”，这说明即使在函数内部修改了参数的值，但原始的引用还保持不变。
实际上，当在函数内部`obj=new Object()`时 这个新的`obj`就已经成为函数内部的局部对象了，这个对象会在函数执行完毕后自动销毁。

**两种变量类型检测**

1. typeof操作符是检测基本类型的最佳工具；
2. **如果变量值是nul或者对象，typeof 将返回“object”；**
3. Instanceof用于检测引用类型，可以检测到具体的，它是什么类型的实例；
4. 如果变量是给定引用类型的实例，instanceof操作符会返回true;

**补充：基本包装类型(包装对象)**
先看下以下代码：

```
var s1 = "helloworld";
var s2 = s1.substr(4);
```

上面我们说到字符串是基本数据类型，不应该有方法，那为什么这里`s1`可以调用`substr()`呢？
ECMAScript还提供了三个特殊的引用类型`Boolean`，`String`，`Number`。我们称这三个特殊的引用类型为**基本包装类型**，也叫**包装对象**。

也就是说当读取`string`，`boolean`和`number`这三个基本数据类型的时候，后台就会创建一个对应的基本包装类型对象，从而让我们能够调用一些方法来操作这些数据.

所以当第二行代码访问`s1`的时候，后台会自动完成下列操作：

- 创建String类型的一个实例；`// var s1 = new String("helloworld");`
- 在实例上调用指定方法；`// var s2 = s1.substr(4);`
- 销毁这个实例；`// s1 = null;`

正因为有第三步这个销毁的动作，所以基本数据类型不可以添加属性和方法，这也正是基本装包类型和引用类型主要区别：**对象的生存期**。

**使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都是一直保存在内存中。自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。**

## 9.跨域 方式 

jsonp

js   这种方式主要是通过动态插入一个script标签。浏览器对script的资源引用没有同源限制，同时资源加载到页面后会立即执行（没有阻塞的情况下）。

css 不会跨域

图片加载img标签不会跨域

ajax请求会跨域

## 10.如何减少回流

innerhtml

什么资源会受到跨域限制 ？ js会吗 css 图片

jsonp

hr面

1.讨厌的特质 喜欢的特质

2.薪资

3.有没有组织过活动

4.保研考研、成绩排名

5.导师的选择

6.跨专业的问题。

7.地点杭州
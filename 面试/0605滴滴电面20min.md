0605滴滴电面 20min

# position 有哪些属性  分别有什么区别

# position：absolute 和 fixed 会带来那些不同

**相同点**：

①元素脱离标准流，不占据标准流空间

②默认覆盖到非定位元素上

③改变行内元素的呈现方式，**display被置为block**

**不同点**：

①absolute的“根元素”是可以设置的，而fixed的根元素固定为**浏览器窗口**

②当滚动网页，fixed元素与浏览器窗口之间的距离是不变的

# display:none和opacity:0 的区别

**display: none;**

  **不占据空间** **不会触发绑定事件 ** **不会被子类继承** **transition无效** 不会引起回流 dom树会有 渲染树不会有

1、浏览器不会生成属性为display: none;的元素。
2、display: none;不占据空间（毕竟都不熏染啦），所以**动态改变此属性时会引起重排**。
3、display: none;**不会被子类继承，但是子类是不会显示的**，毕竟都一起被kill啦。
4、display,是个尴尬的属性，**transition对她无效**。(毫无争议)

**##visibility: hidden;##**

**占据空间 不会触发绑定事件  会被继承** **transition无效** 可反隐藏    会重绘  不会回流

1、元素会被隐藏，但是不会消失，依然占据空间。
2、visibility: hidden会被子类继承，子类也可以通过显示的设置visibility: visible;来反隐藏。
3、visibility: hidden;不会触发该元素已经绑定的事件。
4、visibility: hidden;动态修改此属性会引起重绘。
5、visibility,transition对她无效。(亲测)

**##opacity=0##**

**占据空间 能触发绑定事件  会继承**  **transition有效** 子元素不能反隐藏 会重绘  不会重排

1、opacity=0只是透明度为100%,元素隐藏，依然占据空间。
2、opacity=0会被子元素继承,且，子元素并不能通过opacity=1，进行反隐藏。不能。
3、opacity=0的元素依然能触发已经绑定的事件。
4、opacity,transition对她有效(毫无争议)

**display,opacity,visibility,position隐藏元素的实质**

（1）display:设置属性display:none；,该元素被隐藏，而且该元素的子孙后代也被同时隐藏，此时被隐藏的元素不占据任何空间，用户的交互操作在此元素上不能生效，但是通过js语句操作dom可以来操作该隐藏元素。

实例：

```js
.display-hide {
  display: none;
  transition: all ease 0.8s;
}

.display-hide:hover { /* 当鼠标悬浮在该元素时，设置为block,此时元素也不会出现 ，因为被display隐藏的元素，不占据任何空间，用户的交互操作也不能生效*/
  display: block;
}

.display-hide p {/* 同样的隐藏元素的子孙后代元素也会被隐藏，即使后代元素属性设置为block */
  display: block;
  margin: 0;
  padding: 0;
}
	</style>
</head>
<body>
   <div>鼠标移近来，然后在点击有惊喜哦</div>
    <div class="display-hide"><p>0</p></div>
    <div>第三个div块</div>
    <script>
    var count = 0;
    var DHide = document.getElementsByClassName('display-hide');
    var Div = document.getElementsByTagName('div');

    Div[0].addEventListener("mouseover", function(){
    count++;
    DHide[0].innerHTML = '<p>' +'你的鼠标移近第一个div：'+ count + '次'+'</p>';
   });

    Div[0].addEventListener("click", function(){
    DHide[0].style.display = "block";
  });
    </script>
</body>
```



效果图：

 [![wKioL1dwbhGC8JGAAAAo6I1BFe4101.jpg](https://s3.51cto.com/wyfs02/M02/83/4C/wKioL1dwbhGC8JGAAAAo6I1BFe4101.jpg)](https://s3.51cto.com/wyfs02/M02/83/4C/wKioL1dwbhGC8JGAAAAo6I1BFe4101.jpg)[![wKioL1dwbhySqq05AAAxTzKDmNE614.jpg](https://s5.51cto.com/wyfs02/M02/83/4C/wKioL1dwbhySqq05AAAxTzKDmNE614.jpg)](https://s5.51cto.com/wyfs02/M02/83/4C/wKioL1dwbhySqq05AAAxTzKDmNE614.jpg)

   此例子中，第二个div元素被隐藏，于此同时它的子元素p也被隐藏了，当用户有对第二个div有交互行为，此时是不起作用的，但通过js语句可以来操作该元素，使开元素显示。

（2）opacity:设置属性opacity:0；，只是从视觉的角度隐藏了该元素，而该元素本身还是占据页面中的布局，而且，这种隐藏会响应用户的交互。

实例：

```js
<style>
        div {
  padding: 60px;
  width: 60px;
  font-size: 14px;
  background: pink;
  text-align: center;
  margin: 1%; 
  float: left;
  cursor: pointer;
 }
/* 该元素虽然被隐藏了，看不见了，但它在页面中的位置还是存在的 */
.opacity-hide {
  opacity: 0;
  transition: all ease 0.8s;
}
/* 当鼠标移动到这个隐藏元素上面，元素显示，此时响应了用户的交互行为 */
.opacity-hide:hover {
  opacity: 1;
}
	</style>
</head>
<body>
	<div>1</div>
    <div class="opacity-hide">2</div>
    <div>3</div>
</body>
```



效果图：

[![wKiom1dwbpqxERYGAAAOPMLj_J8860.jpg](https://s3.51cto.com/wyfs02/M02/83/4D/wKiom1dwbpqxERYGAAAOPMLj_J8860.jpg)](https://s3.51cto.com/wyfs02/M02/83/4D/wKiom1dwbpqxERYGAAAOPMLj_J8860.jpg)[![wKiom1dwbqXyz5PGAAAYHaY5pv0257.jpg](https://s1.51cto.com/wyfs02/M02/83/4D/wKiom1dwbqXyz5PGAAAYHaY5pv0257.jpg)](https://s1.51cto.com/wyfs02/M02/83/4D/wKiom1dwbqXyz5PGAAAYHaY5pv0257.jpg)此例中第二个div被隐藏了，我们看不见了，但是它在页面中的位置还是存在着，对用户的操作还是会做响应的，当鼠标滑动到第二块div时，显示。

（3）visibility：设置属性visibility:hidden;,该元素被隐藏，同样隐藏的元素对页面的布局仍起作用，但它不会影响任何用户交互，而且它的子孙元素也会在设置为visibility：visible。

​     

```js
.visibility-hide {
  visibility: hidden;
  transition: all ease 0.8s;
}
/* 虽然设置了隐藏效果，但是不会影响用户的交互操作 */
.visibility-hide:hover {
  visibility: visible;
}
 /* 父元素被隐藏了，这时设置子元素为显示状态，此时子元素显示，但父元素不会显示 */
.visibility-hide p {
  visibility: visible;
  margin: 0;
  padding: 0;
}
	</style>
</head>
<body>
   <div>1</div>
    <div class="visibility-hide"><p id="visi-p">2</p></div>
    <div>3</div>
    <script>
 var oHide = document.getElementsByClassName('visibility-hide');
 var oHideP = document.getElementById('visi-p');
 var count = oHideP.innerHTML;

oHide[0].addEventListener("click", function(){
    count++;
    oHideP.innerHTML = count;
});
    </script>
</body>
```



效果图：

  [![wKioL1dwb7-zOluEAAAQFUBgH-I406.jpg](https://s3.51cto.com/wyfs02/M00/83/4C/wKioL1dwb7-zOluEAAAQFUBgH-I406.jpg)](https://s3.51cto.com/wyfs02/M00/83/4C/wKioL1dwb7-zOluEAAAQFUBgH-I406.jpg)[![wKioL1dwb8uAtAz4AAAT54vAcV0350.jpg](https://s4.51cto.com/wyfs02/M00/83/4C/wKioL1dwb8uAtAz4AAAT54vAcV0350.jpg)](https://s4.51cto.com/wyfs02/M00/83/4C/wKioL1dwb8uAtAz4AAAT54vAcV0350.jpg)此例中，当鼠标移近第二个div时，div的visibility属性变为visible,并为之绑定点击事件。

（4）Position：posiition:absolute;

​             top:-2880px;

​             Left:-2880px;

​         通过设置top,left的值，将元素放在屏幕的可视区域外，这样就达到了元素隐藏的效果。

​     

```js
.position-hide {
  position: absolute;
  top: -9999px;
  left: -9999px;
}

input{
	position: absolute;
	top:-2880px;
	left:-2880px;

}
/* 这个用户效果不会起作用，因为此时的div不在可视区内 */
.position-hide:hover {
  position: static;
}
	</style>
</head>
<body>
	<div>点击元素，有惊喜</div>
    <div class="position-hide"><p>0</p></div>
    <div><input type="radio" value = "获得焦点">3</div>
    <script>
 var count = 0;
var oHide = document.getElementsByClassName('position-hide');
var Div = document.getElementsByTagName('div');
var input = document.getElementsByTagName('input');

Div[0].addEventListener("mouseover", function(){
    count++;
    oHide[0].innerHTML = '<p>' +'你的鼠标移近第一个div：'+ count + '次'+'</p>';
});
Div[2].addEventListener("click",function(){
	input[0].style.position = "static";
});
Div[0].addEventListener("click", function(){

    oHide[0].style.position = "static";
    
});
    </script>
</body>
```



​    效果图：

[![wKiom1dwcKzwU1tmAAAUmRxFqIg057.jpg](https://s5.51cto.com/wyfs02/M00/83/4D/wKiom1dwcKzwU1tmAAAUmRxFqIg057.jpg)](https://s5.51cto.com/wyfs02/M00/83/4D/wKiom1dwcKzwU1tmAAAUmRxFqIg057.jpg)

[![wKiom1dwcLXRUkitAAAlPRjUASo547.jpg](https://s3.51cto.com/wyfs02/M00/83/4D/wKiom1dwcLXRUkitAAAlPRjUASo547.jpg)](https://s3.51cto.com/wyfs02/M00/83/4D/wKiom1dwcLXRUkitAAAlPRjUASo547.jpg)总结： display,opacity,visibility,position，这四种元素隐藏元素各有优缺点，在实际的使用中根据需要，选择合适的。



# 跨域有哪些方法

postMessage

jsonp

CORS

# cookie和webstorage区别

**共同点：  都是保存在浏览器端,且同源的**

**cookie有什么缺点？**

Cookie数量和长度的限制。每个domain最多只能有几十条cookie，每个cookie长度不能超过4KB

安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。

区别：

​        1、cookie数据始终在**同源的http请求中携带**(即使不需要)，即cookie在浏览器和服务器间来回传递

​        2、cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。

​        3、存储大小限制也不同，cookie数据不能超过4K。webStorage虽然也有存储大小的限制，但是比cookie大得多，可以达到5M或更大

​        4、数据的有效期不同

​                        sessionStorage：仅在当前的浏览器窗口关闭有效；

​                        localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；

​                        cookie：只在设置的cookie过期时间之前一直有效，即使窗口和浏览器关闭

​       5、作用域不同

​                        sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面；

​                        localStorage：在所有同源窗口都是共享的；

​                        cookie：也是在所有同源窗口中共享的

​       6、webStorage支持**事件通知机制，可以将数据更新通知给监听者**

​        7、webStorage的API接口使用更方便 。setItem  getItem clearItem

​        window。sessionStorage/window。 localStorage

​        setItem（key,val）设置

​        getItem（key）获取

​        webStorage。removeItem（key）删除单个

​        webStorage.clear（）清除所有

# Cookie与Session的区别

1. cookie数据存放在客户的浏览器上，session数据放在服务器上；
2. cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session；
3. session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE；
4. 单个cookie在客户端的限制是4K，就是说一个站点在客户端存放的COOKIE不能超过4K；

Cookie和Session的方案虽然分别属于客户端和服务端，但是服务端的session的实现对客户端的cookie有依赖关系的，上面我讲到服务端执行session机制时候会生成session的id值，这个id值会发送给客户端，客户端每次请求都会把这个id值放到http请求的头部发送给服务端，而这个id值在客户端会保存下来，保存的容器就是cookie，因此当我们完全禁掉浏览器的cookie的时候，服务端的session也会不能正常使用

# cookie 是哪里形成的

　 cookie机制。正统的cookie分发是通过扩展HTTP协议来实现的，**服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。**然而纯粹的客户端脚本如JavaScript或者VBScript也可以生成cookie。而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。

​    　cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式。 

　　session机制。session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。 

　　**当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识------------称为session id，如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id**，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，**这个session id将被在本次响应中返回给客户端保存。**

​        保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。
​       经常被使用的一种技术叫做**URL重写**，就是把session id直接附加在URL路径的后面。还有一种技术叫做**表单隐藏字段**。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。

# const let 和var的区别

# **var与let、const**

一、var声明的变量会挂载在window上，而let和const声明的变量不会：

```js
var a = 100;
console.log(a,window.a);    // 100 100

let b = 10;
console.log(b,window.b);    // 10 undefined

const c = 1;
console.log(c,window.c);    // 1 undefined
```

二、var声明变量存在变量提升，let和const不存在变量提升

```js
console.log(a); // undefined  ===>  a已声明还没赋值，默认得到undefined值
var a = 100;
console.log(b); // 报错：b is not defined  ===> 找不到b这个变量
let b = 10;
console.log(c); // 报错：c is not defined  ===> 找不到c这个变量
const c = 10;
```

三、let和const声明形成块作用域

```js
if(1){
    var a = 100;
    let b = 10;
}

console.log(a); // 100
console.log(b)  // 报错：b is not defined  ===> 找不到b这个变量
```

```js
if(1){

    var a = 100;
        
    const c = 1;
}
 console.log(a); // 100
 console.log(c)  // 报错：c is not defined  ===> 找不到c这个变量
```

四、同一作用域下let和const不能声明同名变量，而var可以

```js
var a = 100;
console.log(a); // 100

var a = 10;
console.log(a); // 10

let a = 100;
let a = 10;

//  控制台报错：Identifier 'a' has already been declared  ===> 标识符a已经被声明了。
```

五、暂存死区

```

var a = 100;

if(1){
    a = 10;
    //在当前块作用域中存在a使用let/const声明的情况下，给a赋值10时，只会在当前作用域找变量a，
    // 而这时，还未到声明时候，所以控制台Error:a is not defined
    let a = 1;
}
```

六、const

```js

/*
* 　　1、一旦声明必须赋值,不能使用null占位。
*
* 　　2、声明后不能再修改
*
* 　　3、如果声明的是复合类型数据，可以修改其属性
*
* */

const a = 100; 

const list = [];
list[0] = 10;
console.log(list);　　// [10]

const obj = {a:100};
obj.name = 'apple';
obj.a = 10000;
console.log(obj);　　// {a:10000,name:'apple'}
```




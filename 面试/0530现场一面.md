# 网易雷火现场一面

## http头部有哪些

就以上述示例来看，首部字段名为 Content-Type，字符串 text/html 是字段值。
 另外，字段值对应单个 HTTP 首部字段可以有多个值，如下所示。

![img](https://images2015.cnblogs.com/blog/747969/201702/747969-20170217213700816-2042027085.png)

**注意：若** **HTTP** **首部字段重复了会如何？**
 当 HTTP 报文首部中出现了两个或两个以上具有相同首部字段名时会怎么样？这种情况在规范内尚未明确，根据浏览器内部处理逻辑的不同，结果可能并不一致。有些浏览器会优先处理第一次出现的首部字段，而有些则会优先处理最后出现的首部字段。

**6.2.2   4** **种** **HTTP** **首部字段类型**

HTTP 首部字段根据实际用途被分为以下 4 种类型：
 **通用首部字段（****General Header Fields****）**
 请求报文和响应报文两方都会使用的首部。
 **请求首部字段（****Request Header Fields****）**
 从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。
 **响应首部字段（****Response Header Fields****）**
 从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。
 **实体首部字段（****Entity Header Fields****）**
 针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。

**6.2.3**　**HTTP/1.1** **首部字段一览**

HTTP/1.1 规范定义了如下 47 种首部字段。
 表 6-1：**通用首部字段**

图：首部字段**Cache-Control** 能够控制缓存的行为 

指令的参数是可选的，多个指令之间通过“,”分隔。首部字段 Cache-Control 的指令可用于请求及响应时。

```
`Cache-Control: private, max-age=0, no-cache`
```

**Cache-Control 指令一览:**

可用的指令按请求和响应分类如下所示。
表 6-5：**缓存请求指令**
**指令                                  参数         说明**
no-cache                          无            强制向源服务器再次验证
no-store 无 不缓存请求或响应的任何内容
max-age = [ 秒] 必需 响应的最大Age值
max-stale( = [ 秒])
可省 略
接收已过期的响应
min-fresh = [ 秒] 必需 期望在指定时间内的响应仍有效
no-transform 无 代理不可更改媒体类型
only-if-cached 无 从缓存获取资源
cache-extension - 新指令标记（token）

表 6-6：**缓存响应指令**

**指令                                 参数           说明**
public                              无              可向任意方提供响应的缓存
private                            可省略        仅向特定用户返回响应
no-cache                        可省略        缓存前必须先确认其有效性
no-store                         无              不缓存请求或响应的任何内容
no-transform                 无               代理不可更改媒体类型
must-revalidate             无              可缓存但必须再向源服务器进行确认
proxy-revalidate            无              要求中间缓存服务器对缓存的响应有效性再进行 确认
max-age = [ 秒]            必需            响应的最大Age值
s-maxage = [ 秒]          必需             公共缓存服务器响应的最大Age值
cache-extension           -                 新指令标记（token）

**剩下的内容是对上面字段的解析，在 ppt 87页，实在太多了，需要时去看。**

### **6.3.2  Connection**

Connection 首部字段具备如下两个作用。

- 控制不再转发给代理的首部字段
- 管理持久连接

  **1. 控制不再转发给代理的首部字段**

![img](https://images2015.cnblogs.com/blog/747969/201702/747969-20170217214935269-1562584482.png)

```
`Connection: 不再转发的首部字段名`
```

在客户端发送请求和服务器返回响应内，使用 Connection 首部字段，可控制不再转发给代理的首部字段（即 Hop-by-hop 首部）。

  **2. 管理持久连接** 

**![img](https://images2015.cnblogs.com/blog/747969/201702/747969-20170217215009472-1047705671.png)**

 

```
`Connection: close`
```

HTTP/1.1 版本的默认连接都是持久连接。为此，客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 Close。

![img](https://images2015.cnblogs.com/blog/747969/201702/747969-20170217215106738-1770984037.png)

```
`Connection: Keep-Alive　`
```

HTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接。为此，如果想**在旧版本的 HTTP 协议上维持 持续连接，则需要指定 Connection 首部字段的值为 Keep-Alive**。
如上图①所示，客户端发送请求给服务器时，服务器端会像上图②那样加上首部字段 Keep-Alive 及首部字段 Connection 后返回响应。

**太多了，下边的内容只记重要的部分，做了省略。ppt 93页**

### 6.3.3　Date 首部字段

Date 表明创建 HTTP 报文的日期和时间

### 6.3.4　　Pragma

Pragma 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。
规范定义的形式唯一，如下所示。

```
`Pragma: no-cache`
```

该首部字段属于通用首部字段，但只用在客户端发送的请求中。客户端会要求所有的中间服务器不返回缓存 的资源。

所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 Cache-Control: no-cache 指定缓存的处理方式 是最为理想的。但要整体掌握全部中间服务器使用的 HTTP 协议版本却是不现实的。因此，发送的请求会同 时含有下面两个首部字段。

```
`Cache-Control: no-cache``Pragma: no-cache`
```

### 6.3.5　Trailer

 ![img](https://images2015.cnblogs.com/blog/747969/201702/747969-20170217215206707-1504487321.png)

首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在 HTTP/1.1 版本分块传 输编码时。

```
`HTTP/1.1 200 OK``Date: Tue, 03 Jul 2012 04:40:56 GMT``Content-Type: text/html``...``Transfer-Encoding: chunked``Trailer: Expires``...(报文主体)...``0``Expires: Tue, 28 Sep 2004 23:59:59 GMT`
```

以上用例中，指定首部字段 Trailer 的值为 Expires，在报文主体之后（分块长度 0 之后）出现了首部字段 Expires。

### 6.3.6　Transfer-Encoding

首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。

```
`HTTP/1.1 200 OK``Date: Tue, 03 Jul 2012 04:40:56 GMT``Cache-Control: public, max-age=604800``Content-Type: text/javascript; charset=utf-8``Expires: Tue, 10 Jul 2012 04:40:56 GMT``X-Frame-Options: DENY``X-XSS-Protection: 1; mode=block``Content-Encoding: gzip``Transfer-Encoding: chunked``Connection: keep-alive` `cf0    ←16进制(10进制为3312)` `...3312字节分块数据...` `392    ←16进制(10进制为914)` `...914字节分块数据...` `0`
```

以上用例中，正如在首部字段 Transfer-Encoding 中指定的那样，有效使用分块传输编码，且分别被分成 3312 字节和 914 字节大小的分块数据。

### 6.3.7　Upgrade

首部字段 Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定 一个完全不同的通信协议。

### 6.3.8　Via

使用首部字段 Via 是为了追踪客户端与服务器之间的请求和响应报文的传输路径。

### 6.3.9　Warning

HTTP/1.1 的 Warning 首部是从 HTTP/1.0 的响应首部（Retry-After）演变过来的。该首部通常会告知用户一 些与缓存相关的问题的警告。

```
`Warning: 113 gw.hackr.jp:8080 "Heuristic expiration" Tue, 03 Jul 2012 05:09:44 GMT`
```

Warning 首部的格式如下。最后的日期时间部分可省略。

```
`Warning: [警告码][警告的主机:端口号]“[警告内容]”([日期时间])`
```

![img](https://images2015.cnblogs.com/blog/747969/201702/747969-20170217215332425-172139935.png)

**ppt 95页左右**

表 6-2：**请求首部字段**

**首部字段名**                  **说明**
 Accept                         用户代理可处理的媒体类型
 Accept-Charset            优先的字符集
 Accept-Encoding         优先的内容编码
 Accept-Language        优先的语言（自然语言）
 Authorization               Web认证信息
 Expect                          期待服务器的特定行为
 From                             用户的电子邮箱地址
 **Host                              请求资源所在服务器**
 If-Match                        比较实体标记（ETag）
 If-Modified-Since          比较资源的更新时间
 If-None-Match              比较实体标记（与 If-Match 相反）
 If-Range                        资源未更新时发送实体 Byte 的范围请求
 If-Unmodified-Since     比较资源的更新时间（与If-Modified-Since相反）
 Max-Forwards               最大传输逐跳数
 **Proxy-Authorization     代理服务器要求客户端的认证信息**
 **Range                           实体的字节范围请求**
 Referer                          对请求中 URI 的原始获取方
 TE                                  传输编码的优先级
 **User-Agent                   HTTP 客户端程序的信息**

表 6-3：**响应首部字段** 

**首部字段名**                     **说明**
 **Accept-Ranges             是否接受字节范围请求**
 Age                               推算资源创建经过时间
 **ETag                              资源的匹配信息**
 **Location                        令客户端重定向至指定URI**
 **Proxy-Authenticate      代理服务器对客户端的认证信息**
 Retry-After                   对再次发起请求的时机要求
 **Server HTTP                  服务器的安装信息**
 Vary                              代理服务器缓存的管理信息
 WWW-Authenticate     服务器对客户端的认证信息

表 6-4：**实体首部字段**

**首部字段名**                    **说明**
 **Allow                            资源可支持的HTTP方法**
 **Content-Encoding       实体主体适用的编码方式**
**Content-Language      实体主体的自然语言**
 **Content-Length           实体主体的大小（单位：字节）**
 **Content-Location        替代对应资源的URI**
 Content-MD5              实体主体的报文摘要
 **Content-Range            实体主体的位置范围**
 **Content-Type              实体主体的媒体类型**
 **Expires                         实体主体过期的日期时间**
 Last-Modified              资源的最后修改日期时间

**6.2.4**  **非** **HTTP/1.1** **首部字段**

在 HTTP 协议通信交互中使用到的首部字段，不限于 RFC2616 中定义的 47 种首部字段。还有 **Cookie、 Set-Cookie** 和 Content-Disposition 等在其他 RFC 中定义的首部字段，它们的使用频率也很高。
 这些非正式的首部字段统一归纳在 RFC4229 HTTP Header Field Registrations 中。

**6.2.6**　**End-to-end** **首部和****Hop-by-hop** **首部**

HTTP 首部字段将定义成缓存代理和非缓存代理的行为，分成 2 种类型。
 **端到端首部（****End-to-end Header****）**

分在此类别中的首部会转发给请求 / 响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规 定它必须被转发。

**逐跳首部（****Hop-by-hop Header****）**

分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1 和之后版本中，如果要使用 hop-by-hop 首部，需提供 Connection 首部字段。

下面列举了 HTTP/1.1 中的逐跳首部字段。除这 8 个首部字段之外，其他所有字段都属于端到端首部。

·       Connection

·       **Keep-Alive**

·       Proxy-Authenticate

·       Proxy-Authorization

·       Trailer

·       TE

·       Transfer-Encoding

·       Upgrade

**6.3**　**HTTP/1.1** **通用首部字段**

通用首部字段是指，请求报文和响应报文双方都会使用的首部。

**6.3.1  Cache-Control**

通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。

![https://images2015.cnblogs.com/blog/747969/201702/747969-20170217214907410-401420536.png](file:///C:/Users/MWW/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png)

图：首部字段Cache-Control 能能够控制缓存的行为 

指令的参数是可选的，多个指令之间通过“,”分隔。首部字段 Cache-Control 的指令可用于请求及响应时。

| 1    | Cache-Control: private, max-age=0, no-cache |
| ---- | ------------------------------------------- |
|      |                                             |

**Cache-Control** **指令一览****:**

可用的指令按请求和响应分类如下所示。
 表 6-5：**缓存请求指令**
 **指令**                                  **参数**         **说明**
 no-cache                          无            强制向源服务器再次验证
 no-store 无 不缓存请求或响应的任何内容
 max-age = [ 秒] 必需 响应的最大Age值
 max-stale( = [ 秒])
 可省 略
 接收已过期的响应
 min-fresh = [ 秒] 必需 期望在指定时间内的响应仍有效
 no-transform 无 代理不可更改媒体类型
 only-if-cached 无 从缓存获取资源
 cache-extension - 新指令标记（token）

表 6-6：**缓存响应指令**

**指令**                                 **参数**           **说明**
 public                              无              可向任意方提供响应的缓存
 private                            可省略        仅向特定用户返回响应
 no-cache                        可省略        缓存前必须先确认其有效性
 no-store                         无              不缓存请求或响应的任何内容
 no-transform                 无               代理不可更改媒体类型
 must-revalidate             无              可缓存但必须再向源服务器进行确认
 proxy-revalidate            无              要求中间缓存服务器对缓存的响应有效性再进行 确认
 max-age = [ 秒]            必需            响应的最大Age值
 s-maxage = [ 秒]          必需             公共缓存服务器响应的最大Age值
 cache-extension           -                 新指令标记（token）

**剩下的内容是对上面字段的解析，在** **ppt 87****页，实在太多了，需要时去看。**

**6.3.2  Connection**

Connection 首部字段具备如下两个作用。

·       控制不再转发给代理的首部字段 

·       管理持久连接

  **1.** **控制不再转发给代理的首部字段**

![https://images2015.cnblogs.com/blog/747969/201702/747969-20170217214935269-1562584482.png](file:///C:/Users/MWW/AppData/Local/Temp/msohtmlclip1/01/clip_image006.png)

| 1    | Connection: 不再转发的首部字段名 |
| ---- | -------------------------------- |
|      |                                  |

在客户端发送请求和服务器返回响应内，使用 Connection 首部字段，可控制不再转发给代理的首部字段（即 Hop-by-hop 首部）。

  **2.** **管理持久连接** 

**![https://images2015.cnblogs.com/blog/747969/201702/747969-20170217215009472-1047705671.png](file:///C:/Users/MWW/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png)**

 

| 1    | Connection: close |
| ---- | ----------------- |
|      |                   |

HTTP/1.1 版本的默认连接都是持久连接。为此，客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 Close。

![https://images2015.cnblogs.com/blog/747969/201702/747969-20170217215106738-1770984037.png](file:///C:/Users/MWW/AppData/Local/Temp/msohtmlclip1/01/clip_image010.png)

| 1    | Connection: Keep-Alive |
| ---- | ---------------------- |
|      |                        |

HTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接。为此，如果想**在旧版本的** **HTTP** **协议上维持** **持续连接，则需要指定** **Connection** **首部字段的值为** **Keep-Alive**。
 如上图①所示，客户端发送请求给服务器时，服务器端会像上图②那样加上首部字段 Keep-Alive 及首部字段 Connection 后返回响应。

**太多了，下边的内容只记重要的部分，做了省略。****ppt 93****页**

**6.3.3**　**Date** **首部字段**

Date 表明创建 HTTP 报文的日期和时间

**6.3.4**　　**Pragma**

Pragma 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。
 规范定义的形式唯一，如下所示。

| 1    | Pragma: no-cache |
| ---- | ---------------- |
|      |                  |

该首部字段属于通用首部字段，但只用在客户端发送的请求中。客户端会要求所有的中间服务器不返回缓存 的资源。

所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 Cache-Control: no-cache 指定缓存的处理方式 是最为理想的。但要整体掌握全部中间服务器使用的 HTTP 协议版本却是不现实的。因此，发送的请求会同 时含有下面两个首部字段。

| 1   2 | Cache-Control: no-cache   Pragma: no-cache |
| ----- | ------------------------------------------ |
|       |                                            |

**6.3.5**　**Trailer**

 ![https://images2015.cnblogs.com/blog/747969/201702/747969-20170217215206707-1504487321.png](file:///C:/Users/MWW/AppData/Local/Temp/msohtmlclip1/01/clip_image012.png)

首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在 HTTP/1.1 版本分块传 输编码时。

| 1   2   3   4   5   6   7   8   9 | HTTP/1.1 200 OK   Date: Tue, 03 Jul 2012 04:40:56 GMT   Content-Type: text/html   ...   Transfer-Encoding: chunked   Trailer: Expires   ...(报文主体)...   0   Expires: Tue, 28 Sep 2004 23:59:59 GMT |
| --------------------------------- | ------------------------------------------------------------ |
|                                   |                                                              |

以上用例中，指定首部字段 Trailer 的值为 Expires，在报文主体之后（分块长度 0 之后）出现了首部字段 Expires。

**6.3.6**　**Transfer-Encoding**

首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。

| 1   2   3   4   5   6   7   8   9   10   11   12   13   14   15   16   17   18   19   20 | HTTP/1.1 200 OK   Date: Tue, 03 Jul 2012 04:40:56 GMT   Cache-Control: public, max-age=604800   Content-Type: text/javascript; charset=utf-8   Expires: Tue, 10 Jul 2012 04:40:56 GMT   X-Frame-Options: DENY   X-XSS-Protection: 1; mode=block   Content-Encoding: gzip   Transfer-Encoding: chunked   Connection: keep-alive       cf0    ←16进制(10进制为3312)       ...3312字节分块数据...       392    ←16进制(10进制为914)       ...914字节分块数据...       0 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

以上用例中，正如在首部字段 Transfer-Encoding 中指定的那样，有效使用分块传输编码，且分别被分成 3312 字节和 914 字节大小的分块数据。

**6.3.7**　**Upgrade**

首部字段 Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定 一个完全不同的通信协议。

**6.3.8**　**Via**

使用首部字段 Via 是为了追踪客户端与服务器之间的请求和响应报文的传输路径。

**6.3.9**　**Warning**

HTTP/1.1 的 Warning 首部是从 HTTP/1.0 的响应首部（Retry-After）演变过来的。该首部通常会告知用户一 些与缓存相关的问题的警告。

| 1    | Warning: 113 gw.hackr.jp:8080 "Heuristic   expiration" Tue, 03 Jul 2012 05:09:44 GMT |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

Warning 首部的格式如下。最后的日期时间部分可省略。

| 1    | Warning: [警告码][警告的主机:端口号]“[警告内容]”([日期时间]) |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

![https://images2015.cnblogs.com/blog/747969/201702/747969-20170217215332425-172139935.png](file:///C:/Users/MWW/AppData/Local/Temp/msohtmlclip1/01/clip_image014.png)

**ppt 95****页左右**

**6.4**　　**请求首部字段**

请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加信息、客户端信 息、对响应内容相关的优先级等内容。

**6.4.1**　　**Accept**

| 1    | Accept:   text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

Accept 首部字段可通知服务器，**用户代理能够处理的媒体类型及媒体类型的相对优先级**。可使用 type/subtype 这种形式，一次指定多种媒体类型。
 下面我们试举几个媒体类型的例子。

文本文件

| 1   2 | text/html, text/plain, text/css ...   application/xhtml+xml, application/xml ... |
| ----- | ------------------------------------------------------------ |
|       |                                                              |

图片文件

| 1    | image/jpeg, image/gif, image/png ... |
| ---- | ------------------------------------ |
|      |                                      |

视频文件

| 1    | video/mpeg, video/quicktime ... |
| ---- | ------------------------------- |
|      |                                 |

应用程序使用的二进制文件

| 1    | application/octet-stream, application/zip ... |
| ---- | --------------------------------------------- |
|      |                                               |

比如，如果浏览器不支持 PNG 图片的显示，那 Accept 就不指定 image/png，而指定可处理的 image/gif 和 image/jpeg 等图片类型。 若想要给显示的媒体类型增加优先级，则使用 q= 来额外表示权重值 1，用分号（;）进行分隔。权重值 q 的 范围是 0~1（可精确到小数点后 3 位），且 1 为最大值。不指定权重 q 值时，默认权重为 q=1.0。
 1 原文是“品質係数”。在 RFC2616 定义中，此处的 q 是指 qvalue，即 quality factor。直译的话就是质量数，但经过综合考虑理 解记忆的便利性后，似乎采用权重值更为稳妥。——译者注
 当服务器提供多种内容时，将会首先返回权重值最高的媒体类型。

**6.4.2**　　**Accept-Charset**

| 1    | Accept-Charset: iso-8859-5, unicode-1-1;q=0.8 |
| ---- | --------------------------------------------- |
|      |                                               |

Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次 性指定多种字符集。与首部字段 Accept 相同的是可用权重 q 值来表示相对优先级。
 该首部字段应用于内容协商机制的服务器驱动协商。

6.4.3　Accept-Encoding

| 1    | Accept-Encoding: gzip, deflate |
| ---- | ------------------------------ |
|      |                                |

Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。可一次性指 定多种内容编码。
 下面试举出几个内容编码的例子。
   **gzip**
    由文件压缩程序 gzip（GNU zip）生成的编码格式（RFC1952），采用 Lempel-Ziv 算法    （LZ77）及 32 位循环冗余校验（Cyclic Redundancy Check，通称 CRC）。
     **compress**
     由 UNIX 文件压缩程序 compress 生成的编码格式，采用 Lempel-Ziv-Welch 算法（LZW）。
     **deflate**
     组合使用 zlib 格式（RFC1950）及由 deflate 压缩算法（RFC1951）生成的编码格式。
     **identity**
     不执行压缩或不会变化的默认编码格式
 采用权重 q 值来表示相对优先级，这点与首部字段 Accept 相同。另外，也可使用星号（*）作为通配符，指 定任意的编码格式。

6.4.4　Accept-Language

| 1    | Accept-Language: zh-cn,zh;q=0.7,en-us,en;q=0.3 |
| ---- | ---------------------------------------------- |
|      |                                                |

首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然 语言集的相对优先级。可一次指定多种自然语言集。
 和 Accept 首部字段一样，按权重值 q 来表示相对优先级。在上述图例中，客户端在服务器有中文版资源的情 况下，会请求其返回中文版对应的响应，没有中文版时，则请求返回英文版响应。

6.4.5　Authorization

| 1    | Authorization: Basic dWVub3NlbjpwYXNzd29yZA== |
| ---- | --------------------------------------------- |
|      |                                               |

首部字段 Authorization 是用来告知服务器，用户代理的认证信息（证书值）。通常，想要通过服务器认证的 用户代理会在接收到返回的 401 状态码响应后，把首部字段 Authorization 加入请求中。共用缓存在接收到含 有 Authorization 首部字段的请求时的操作处理会略有差异。
 有关 HTTP 访问认证及 Authorization 首部字段，稍后的章节还会详细说明。另外，读者也可参阅 RFC2616。

6.4.6　Expect

| 1    | Expect: 100-continue |
| ---- | -------------------- |
|      |                      |

客户端使用首部字段 Expect 来告知服务器，期望出现的某种特定行为。因服务器无法理解客户端的期望作出 回应而发生错误时，会返回状态码 417 Expectation Failed。
 客户端可以利用该首部字段，写明所期望的扩展。虽然 HTTP/1.1 规范只定义了 100-continue（状态码 100 Continue 之意）。
 等待状态码 100 响应的客户端在发生请求时，需要指定 Expect:100-continue

6.4.7  From

首部字段 From 用来告知服务器使用用户代理的用户的电子邮件地址。通常，其使用目的就是为了显示搜索 引擎等用户代理的负责人的电子邮件联系方式。使用代理时，应尽可能包含 From 首部字段（但可能会因代 理不同，将电子邮件地址记录在 User-Agent 首部字段内）。

6.4.8　　Host

| 1    | Host: www.hackr.jp |
| ---- | ------------------ |
|      |                    |

首部字段 Host 会告知服务器，请求的资源所处的互联网主机名和端口号。Host 首部字段在 HTTP/1.1 规范内是唯一一个必须被包含在请求内的首部字段。
 首部字段 Host 和以单台服务器分配多个域名的虚拟主机的工作机制有很密切的关联，这是首部字段 Host 必须存在的意义。

6.4.9  If-xxx 

![https://images2015.cnblogs.com/blog/747969/201702/747969-20170217215624582-511972347.png](file:///C:/Users/MWW/AppData/Local/Temp/msohtmlclip1/01/clip_image016.png)

形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条 件为真时，才会执行请求。

**每个****if****的详细内容去看****ppt106****页，实在是太多了**

6.4.16　　Range

| 1    | Range: bytes=5001-10000 |
| ---- | ----------------------- |
|      |                         |

对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。上面的示例表示 请求获取从第 5001 字节至第 10000 字节的资源。

**6.4.19**　**User-Agent**

| 1    | User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101 Firefox/13.0.1 |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。
 由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件地址。此外，如果请求经过代理，那么 中间也很可能被添加上代理服务器的名称。

**6.5**　**响应首部字段**

响应首部字段是由服务器端向客户端返回响应报文中所使用的字段，用于补充响应的附加信息、服务器信 息，以及对客户端的附加要求等信息。

**6.5.1**　　**Accept-Ranges**

当不能处理范围请求时，Accept-Ranges: none

| 1    | Accept-Ranges: bytes |
| ---- | -------------------- |
|      |                      |

首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资 源。
 可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则指定其为 none。

**6.5.2**　　**Age**

| 1    | Age: 600 |
| ---- | -------- |
|      |          |

首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。
 若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次发起认证到认证完成的时间值。代理创 建响应时必须加上首部字段 Age。

**6.6**　　**实体首部字段**

实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息。

**6.6.1**　　**Allow**

| 1    | Allow: GET, HEAD |
| ---- | ---------------- |
|      |                  |

首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。当服务器接收到不支持 的 HTTP 方法时，会以状态码 405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回。

**6.6.2**　　**Content-Encoding**

**Content-Encoding: gzip**

首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不 丢失实体信息的前提下所进行的压缩。

主要采用以下 4 种内容编码的方式。（各方式的说明请参考 6.4.3 节 Accept-Encoding 首部字段）。
 gzip
 compress
 deflate
 identity

6.6.3　Content-Language

Content-Language: zh-CN
 首部字段 Content-Language 会告知客户端，实体主体使用的自然语言（指中文或英文等语言）。

6.6.4　Content-Length

Content-Length: 15000
 首部字段 Content-Length 表明了实体主体部分的大小（单位是字节）。对实体主体进行内容编码传输时，不 能再使用 Content-Length 首部字段。由于实体主体大小的计算方法略微复杂，所以在此不再展开。

6.6.5　　Content-Location

| 1    | Content-Location: http://www.hackr.jp/index-ja.html |
| ---- | --------------------------------------------------- |
|      |                                                     |

首部字段 Content-Location 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，ContentLocation 表示的是报文主体返回资源对应的 URI。

比如，对于使用首部字段 Accept-Language 的服务器驱动型请求，当返回的页面内容与实际请求的对象不同 时，首部字段 Content-Location 内会写明 URI。（访问 http://www.hackr.jp/ 返回的对象却是 http://www.hackr.jp/index-ja.html 等类似情况）

6.6.6　Content-MD5

Content-MD5: OGFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY==
 首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完 整，以及确认传输到达。

6.6.7　　Content-Range

Content-Range: bytes 5001-10000/10000
 针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分 符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。

6.6.8　　Content-Type

Content-Type: text/html; charset=UTF-8
 首部字段 Content-Type 说明了实体主体内对象的媒体类型。和首部字段 Accept 一样，字段值用 type/subtype 形式赋值。
 参数 charset 使用 iso-8859-1 或 euc-jp 等字符集进行赋值。

6.6.9　　Expires

Expires: Wed, 04 Jul 2012 08:26:05 GMT

首部字段 Expires 会将资源失效的日期告知客户端。缓存服务器在接收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在 Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后， 缓存服务器在请求发送过来时，会转向源服务器请求资源。

6.6.10　　Last-Modified

Last-Modified: Wed, 23 May 2012 09:59:55 GMT
 首部字段 Last-Modified 指明资源最终修改的时间。一般来说，这个值就是 Request-URI 指定资源被修改的 时间。但类似使用 CGI 脚本进行动态数据处理时，该值有可能会变成数据最终修改时的时间。

**ppt 121****页**

**6.7**　**为** **Cookie** **服务的首部字段**  

**ppt 125****页**

管理服务器与客户端之间状态的 Cookie，虽然没有被编入标准化 HTTP/1.1 的 RFC2616 中，但在 Web 网 站方面得到了广泛的应用。
 Cookie 的工作机制是用户识别及状态管理。Web 网站为了管理用户的状态会通过 Web 浏览器，把一些数据 临时写入用户的计算机内。接着当用户访问该Web网站时，可通过通信方式取回之前发放的 Cookie。

下面的表格内列举了与 Cookie 有关的首部字段。

表 6-8：**为** **Cookie** **服务的首部字段**

**首部字段名**                 **说明**                                                 **首部类型**
 Set-Cookie                开始状态管理所使用的Cookie信息     响应首部字段
 Cookie                      服务器接收到的Cookie信息                请求首部字段

**6.7.1**　　**Set-Cookie**

| 1    | Set-Cookie: status=enable; expires=Tue, 05 Jul 2011 07:26:31 GMT; path=/; domain=.hackr.jp; |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

当服务器准备开始管理客户端的状态时，会事先告知各种信息。
 下面的表格列举了 Set-Cookie 的字段值。

表 6-9：：Set-Cookie 字段的属性
 **属性**                                **说明**
 NAME=VALUE               赋予 Cookie 的名称和其值（必需项）
 expires=DATE               Cookie的有效期（若不明确指定则默认为浏览器关闭前为止）
 path=PATH                   将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档 所在的文件目录）
 domain=域名                作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie 的服务 器的域名）
 Secure                           仅在 HTTPS 安全通信时才会发送 Cookie
 HttpOnly                       加以限制，使 Cookie 不能被 JavaScript 脚本访问

**expires** **属性**

Cookie 的 expires 属性指定浏览器可发送 Cookie 的有效期。
 当省略 expires 属性时，其有效期仅限于维持浏览器会话（Session）时间段内。这通常限于浏览器应用程序被关闭之前。
 另外，一旦 Cookie 从服务器端发送至客户端，服务器端就不存在可以显式删除 Cookie 的方法。但可通过覆盖已过期的 Cookie，实现对客户端 Cookie 的实质性删除操作。

**6.7.2**　　**Cookie**

Cookie: status=enable

首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。

**6.8**　**其他首部字段**

HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段。
 接下来，我们就一些最为常用的首部字段进行说明。

·       X-Frame-Options

·       X-XSS-Protection

·       DNT

·       P3P

## 字符集

### charset

使用UTF8编码(国际化编码)

<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
使用中文gbk编码

<meta http-equiv="content-type" content="text/html; charset=gbk" />
使用简体中文gb18030编码

<meta http-equiv="content-type" content="text/html; charset=gb18030" />
在[XHTML](https://baike.baidu.com/item/XHTML)、[HTML5](https://baike.baidu.com/item/HTML5)中使用

<meta charset="UTF-8" />
<meta charset="gbk" />
<meta charset="gb18030" />
## 编码格式

**accept-encoding**

**HTTP Header中Accept-Encoding 是浏览器发给服务器,声明浏览器支持的编码类型** 

**常见的有**

Accept-Encoding: compress, gzip //支持compress 和gzip类型

Accept-Encoding:　//默认是identity

Accept-Encoding: *　//支持所有类型 Accept-Encoding: compress;q=0.5, gzip;q=1.0//按顺序支持 gzip , compress

Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0 // 按顺序支持 gzip , identity

服务器返回的对应的类型编码header是 content-encoding.服务器处理accept-encoding的规则如下所示　1. 如果服务器可以返回定义在Accept-Encoding 中的任何一种Encoding类型, 那么处理成功(除非q的值等于0, 等于0代表不可接受)

\2. * 代表任意一种Encoding类型 (除了在Accept-Encoding中显示定义的类型)

3.如果有多个Encoding同时匹配, 按照q值顺序排列

\4. identity总是可被接受的encoding类型(除非显示的标记这个类型q=0) ,

如果Accept-Encoding的值是空, 那么只有identity是会被接受的类型

如果Accept-Encoding中的所有类型服务器都没发返回, 那么应该返回406错误给客户端

如果request中没有Accept-Encoding 那么服务器会假设所有的Encoding都是可以被接受的。

如果Accept-Encoding中有identity 那么应该优先返回identity (除非有q值的定义,或者你认为另外一种类型是更有意义的)

注意:

如果服务器不支持identity 并且浏览器没有发送Accept-Encoding,那么服务器应该倾向于使用HTTP1.0中的 "gzip" and "compress" , 服务器可能按照客户端类型 发送更适合的encoding类型大部分HTTP1.0的客户端无法处理q值

GZIP最早由Jean-loup Gailly和Mark Adler创建，用于[UNIX](https://baike.baidu.com/item/UNIX)系统的[文件压缩](https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9)。我们在[Linux](https://baike.baidu.com/item/Linux)中经常会用到后缀为.gz的文件，它们就是GZIP格式的。现今已经成为Internet 上使用非常普遍的一种[数据压缩](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9)格式，或者说一种文件格式。　HTTP协议上的GZIP编码是一种用来改进WEB应用程序性能的技术。大流量的WEB站点常常使用GZIP[压缩技术](https://baike.baidu.com/item/%E5%8E%8B%E7%BC%A9%E6%8A%80%E6%9C%AF)来让用户感受更快的速度。这一般是指WWW服务器中安装的一个功能,当有人来访问这个服务器中的网站时,服务器中的这个功能就将网页内容压缩后传输到来访的电脑浏览器中显示出来.一般对纯文本内容可压缩到原大小的40%.这样传输就快了,效果就是你点击网址后会很快的显示出来.当然这也会增加服务器的负载. 一般服务器中都安装有这个功能模块的.

## css3 一个小球动来动去

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        .ball {
            position: relative;
            width:100px;
            height:100px;
            background-color: red;
            border-radius: 100px;
            animation:moveball 2s infinite;
        }
        @keyframes moveball {
            0% {
                left:0;
                top:0;
            }
            25% {
                left:100px;
                top:0;
            }
            50% {
                left:100px;
                top:100px;
            }
            75% {
                left:0;
                top:100px;
            }
            100% {
                left:0;
                top:0;
            }
        }
        /* @keyframes moveball {
            0% {

            }
            25% {
                transform:translate(100px, 0);
            }
            50% {
                transform:translate(100px, 100px);
            }
            75% {
                transform:translate(0, 100px);
            }
            100% {
                transform:translate(0, 0);
            }
        } */
    </style>
</head>
<body>
    <div class="ball"></div>
</body>
</html>
```



## 强制缓存

详细 <https://www.cnblogs.com/chenqf/p/6386163.html>

<https://segmentfault.com/a/1190000015816331>

### 一 强制缓存

强制缓存整体流程比较简单，**就是在第一次访问服务器取到数据之后，在过期时间之内不会再去重复请求**。实现这个流程的核心就是如何知道当前时间是否超过了过期时间。

强制缓存的过期时间通过第一次访问服务器时返回的响应头获取。在 `http 1.0` 和 `http 1.1` 版本中通过不同的响应头字段实现。

http 1.0

在 `http 1.0` 版本中，强制缓存通过 `Expires` 响应头来实现。 `expires` 表示未来资源会过期的时间。也就是说，当发起请求的时间超过了 `expires` 设定的时间，即表示资源缓存时间到期，会发送请求到服务器重新获取资源。而如果发起请求的时间在 `expires` 限定的时间之内，浏览器会直接读取本地缓存数据库中的信息（`from memory` or `from disk`），两种方式根据浏览器的策略随机获取。

http 1.1

在 `http 1.1` 版本中，强制缓存通过 `Cache-Control` 响应头来实现。`Cache-Control` 拥有多个值：

> **private**：客户端可以缓存
> **public**：客户端和代理服务器均可缓存；
> **max-age=xxx**：缓存的资源将在 xxx 秒后过期；
> **no-cache**：需要使用协商缓存来验证是否过期；
> **no-store**：不可缓存

最常用的字段就是 `max-age=xxx` ，表示缓存的资源将在 xxx 秒后过期。一般来说，为了兼容，两个版本的强制缓存都会被实现。

总结

强制缓存只有首次请求才会跟服务器通信，读取缓存资源时不会发出任何请求，资源的 `Status` 状态码为 `200`，资源的 `Size` 为 `from memory` 或者 `from disk` ，http 1.1 版本的实现优先级会高于 http 1.0 版本的实现。

### 二 协商缓存

协商缓存与强制缓存的不同之处在于，**协商缓存每次读取数据时都需要跟服务器通信，并且会增加缓存标识。在第一次请求服务器时，服务器会返回资源，并且返回一个资源的缓存标识。当第二次请求资源时，浏览器会首先将缓存标识发送给服务器，服务器拿到标识后判断标识是否匹配，如果不匹配，表示资源有更新，服务器会将新数据和新的缓存标识一起返回到浏览器；如果缓存标识匹配，表示资源没有更新，并且返回 `304` 状态码，浏览器就读取本地缓存中的数据。**

在 http 协议的 `1.0` 和 `1.1` 版本中也有不同的实现方式。

http 1.0

在 `http 1.0` 版本中，第一次请求资源时服务器通过 `Last-Modified` 来设置响应头的缓存标识，并且把资源最后修改的时间作为值填入，然后将资源返回给浏览器。在第二次请求时，浏览器会首先带上 `If-Modified-Since` 请求头去访问服务器，服务器会将 `If-Modified-Since` 中携带的时间与资源修改的时间匹配，如果时间不一致，服务器会返回新的资源，并且将 `Last-Modified` 值更新，作为响应头返回给浏览器。如果时间一致，表示资源没有更新，服务器返回 304 状态码，浏览器拿到响应状态码后从本地缓存数据库中读取缓存资源。

这种方式有一个弊端，就是当服务器中的资源增加了一个字符，后来又把这个字符删掉，本身资源文件并没有发生变化，但修改时间发生了变化。当下次请求过来时，服务器也会把这个本来没有变化的资源重新返回给浏览器。

http 1.1

在 `http 1.1` 版本中，服务器通过 `Etag` 来设置响应头缓存标识。`Etag` 的值由服务端生成。在第一次请求时，服务器会将资源和 `Etag` 一并返回给浏览器，浏览器将两者缓存到本地缓存数据库。在第二次请求时，浏览器会将 `Etag` 信息放到 `If-None-Match` 请求头去访问服务器，服务器收到请求后，会将服务器中的文件标识与浏览器发来的标识进行对比，如果不相同，服务器返回更新的资源和新的 `Etag` ，如果相同，服务器返回 `304` 状态码，浏览器读取缓存。

总结

协商缓存每次请求都会与服务器交互，第一次是拿数据和标识的过程，第二次开始，就是浏览器询问服务器资源是否有更新的过程。每次请求都会传输数据，如果命中缓存，则资源的 `Status` 状态码为 `304` 而不是 `200` 。同样的，一般来讲为了兼容，两个版本的协商缓存都会被实现，`http 1.1` 版本的实现优先级会高于 `http 1.0` 版本的实现。



## 深拷贝

## 跨域

前面不同.taobao.com
ip地址-url 对应 算跨域吗

## grid 

## flex

## webpack

### webpack 多个出口配置 a.html b.html

<https://www.cnblogs.com/zhensg123/p/9298335.html>

- 我在网上找了webpack配置的相关资料, html与js的对应关系都是, "一对一", "多对一", 但很少有"多对多"的实现

**但经过一番折腾, 最终还是被我配置出来了,这里分享一下配置文件相关的语法**

```js
    //entry入口文件支持json的形式
    entry: {
        "static/pc/js/index": "./webStatic/pc/js/index.js",
        "static/pc/js/article-details": "./webStatic/pc/js/article-details.js",
        "static/mobile/js/index": "./webStatic/mobile/js/index.js",
        "static/mobile/js/article-details": "./webStatic/mobile/js/article-details.js"
    },
    output: {
        path: path.resolve(__dirname, ''),
        //filename前面我们可以使用一个变量[name],这个就表示获取entry里面的key作为文件名加在前面
        filename: '[name].js'
    }
```

配置说明

> - 根目录下`webStatic`为源码放置的位置, 根目录下`static`为js输出的的位置
> - 配置文件共进行了四个映射: `webStatic/pc/js/index.js`输出到`static/pc/js/index.js`, `./webStatic/pc/js/article-details.js` 输出到`static/pc/js/article-details.js`, `./webStatic/mobile/js/index.js`输出到`static/mobile/js/index.js`, `./webStatic/mobile/js/article-details.js`输出到`static/mobile/js/article-details.js`
> - 以后添加其它映射, 只需在`entry`内,按照格式添加即可(对着抄就行)

你是怎么实现跨域的webpack

## vue原理

已经了解到vue是通过数据劫持结合观察者订阅者模式来做数据绑定的，其中最核心的方法便是通过`Object.defineProperty()` 重写属性的setter和getter方法来实现对属性的劫持
整理了一下，要实现mvvm的双向绑定，就必须要实现以下几点：
1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者
2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数
3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图
4、mvvm入口函数，整合以上三者

## git

1、首先我们要先在命令框里输入这个命令 将存储库克隆到新目录中。（在这之前你要先安装好git并配好环境）

git clone<版本库的网址>（https://gitee.com/zzfeiduJava/ShopProject.git）
1
2、第二步我们要先查询一下工作区的状态

git status命令用于显示**工作目录和暂存区**的状态
1
3、 把代码添加到本地仓库

git add . //全部添加     
git add 文件名 //提交指定文件
1
2
4、接下来就是提交了

git commit -m '111' //单引号里边是备注内容，也是给你这次提交起个名字
1
5、最后就是 git push 命令

 git push  <远程主机名>  <本地分支名>  //例如 git push origin master
 将本地的master分支推送到远程主机origin上的对应master分支， origin 是远程主机名，master是本地分支名
1
2

另外需要注意的是，查询过状态之后，一般都需要用get pull命令先把远程的代码更新到本地然后再上传。

## 常用linux命令

**系统信息** 
arch 显示机器的处理器架构(1) 
uname -m 显示机器的处理器架构(2) 
uname -r 显示正在使用的内核版本 
dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI) 
hdparm -i /dev/hda 罗列一个磁盘的架构特性 
hdparm -tT /dev/sda 在磁盘上执行测试性读取操作 
cat /proc/cpuinfo 显示CPU info的信息 
cat /proc/interrupts 显示中断 
cat /proc/meminfo 校验内存使用 
cat /proc/swaps 显示哪些swap被使用 
cat /proc/version 显示内核的版本 
cat /proc/net/dev 显示网络适配器及统计 
cat /proc/mounts 显示已加载的文件系统 
lspci -tv 罗列 PCI 设备 
lsusb -tv 显示 USB 设备 
date 显示系统日期 
cal 2007 显示2007年的日历表 
date 041217002007.00 设置日期和时间 - 月日时分年.秒 
clock -w 将时间修改保存到 BIOS 



**关机 (系统的关机、重启以及登出 )** 
shutdown -h now 关闭系统(1) 
init 0 关闭系统(2) 
telinit 0 关闭系统(3) 
shutdown -h hours:minutes & 按预定时间关闭系统 
shutdown -c 取消按预定时间关闭系统 
shutdown -r now 重启(1) 
reboot 重启(2) 
logout 注销 



**文件和目录** 
**cd /home 进入 '/ home' 目录'** 
**cd .. 返回上一级目录** 
**cd ../.. 返回上两级目录** 
**cd 进入个人的主目录** 
**cd ~user1 进入个人的主目录** 
**cd - 返回上次所在的目录** 
**pwd 显示工作路径** 
**ls 查看目录中的文件** 
**ls -F 查看目录中的文件** 
**ls -l 显示文件和目录的详细资料** 
**ls -a 显示隐藏文件** 
**ls *[0-9]* 显示包含数字的文件名和目录名**
**tree 显示文件和目录由根目录开始的树形结构(1)** 
**lstree 显示文件和目录由根目录开始的树形结构(2)** 
**mkdir dir1 创建一个叫做 'dir1' 的目录'** 
**mkdir dir1 dir2 同时创建两个目录** 
**mkdir -p /tmp/dir1/dir2 创建一个目录树** 
**rm -f file1 删除一个叫做 'file1' 的文件'** 
**rmdir dir1 删除一个叫做 'dir1' 的目录'** 
**rm -rf dir1 删除一个叫做 'dir1' 的目录并同时删除其内容** 
**rm -rf dir1 dir2 同时删除两个目录及它们的内容** 
**mv dir1 new_dir 重命名/移动 一个目录** 
**cp file1 file2 复制一个文件** 
**cp dir/* . 复制一个目录下的所有文件到当前工作目录** 
**cp -a /tmp/dir1 . 复制一个目录到当前工作目录** 
cp -a dir1 dir2 复制一个目录** 
ln -s file1 lnk1 创建一个指向文件或目录的软链接 
ln file1 lnk1 创建一个指向文件或目录的物理链接 
touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm) 
file file1 outputs the mime type of the file as text 
iconv -l 列出已知的编码 
iconv -f fromEncoding -t toEncoding inputFile > outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding. 
find . -maxdepth 1 -name *.jpg -print -exec convert "{}" -resize 80x60 "thumbs/{}" \; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) 

## symbol是干嘛用的

#### 这是一种新的基础数据类型（primitive type）

`Symbol`是由ES6规范引入的一项新特性，它的功能类似于一种标识唯一性的ID。通常情况下，我们可以通过调用`Symbol()`函数来创建一个Symbol实例：

```js
let s1 = Symbol()
```

或者，你也可以在调用`Symbol()`函数时传入一个可选的字符串参数，相当于给你创建的Symbol实例一个描述信息：

```js
let s2 = Symbol('another symbol')
```

如果用当下比较流行的TypeScript的方式来描述这个`Symbol()`函数的话，可以表示成：

```js
/**
 * @param  {any} description 描述信息。可以是任何可以被转型成字符串的值，如：字符串、数字、对象、数组等
 */
function Symbol(description?: any): symbol
```

由于`Symbol`是一种基础数据类型，所以当我们使用`typeof`去检查它的类型的时候，它会返回一个属于自己的类型`symbol`，而不是什么`string`、`object`之类的：

```js
typeof s1  // 'symbol'
```

另外，我们需要重点记住的一点是：每个Symbol实例都是唯一的。因此，当你比较两个Symbol实例的时候，将总会返回`false`：

```js
let s1 = Symbol()
let s2 = Symbol('another symbol')
let s3 = Symbol('another symbol')

s1 === s2 // false
s2 === s3 // false
```

#### 应用场景1：使用Symbol来作为对象属性名(key)

在这之前，我们通常定义或访问对象的属性时都是使用字符串，比如下面的代码：

```js
let obj = {
  abc: 123,
  "hello": "world"
}

obj["abc"] // 123
obj["hello"] // 'world'
```

而现在，`Symbol`可同样用于对象属性的定义和访问：

```js
const PROP_NAME = Symbol()
const PROP_AGE = Symbol()

let obj = {
  [PROP_NAME]: "一斤代码"
}
obj[PROP_AGE] = 18

obj[PROP_NAME] // '一斤代码'
obj[PROP_AGE] // 18
```

随之而来的是另一个非常值得注意的问题：就是当使用了Symbol作为对象的属性key后，在对该对象进行key的枚举时，会有什么不同？在实际应用中，我们经常会需要使用`Object.keys()`或者`for...in`来枚举对象的属性名，那在这方面，Symbol类型的key表现的会有什么不同之处呢？来看以下示例代码：

```js
let obj = {
   [Symbol('name')]: '一斤代码',
   age: 18,
   title: 'Engineer'
}

Object.keys(obj)   // ['age', 'title']

for (let p in obj) {
   console.log(p)   // 分别会输出：'age' 和 'title'
}

Object.getOwnPropertyNames(obj)   // ['age', 'title']
```

由上代码可知，Symbol类型的key是不能通过`Object.keys()`或者`for...in`来枚举的，它未被包含在对象自身的属性名集合(property names)之中。所以，利用该特性，我们可以把一些不需要对外操作和访问的属性使用Symbol来定义。

也正因为这样一个特性，当使用`JSON.stringify()`将对象转换成JSON字符串的时候，Symbol属性也会被排除在输出内容之外：

```js
JSON.stringify(obj)  // {"age":18,"title":"Engineer"}js
```

我们可以利用这一特点来更好的设计我们的数据对象，让“对内操作”和“对外选择性输出”变得更加优雅。

然而，这样的话，我们就没办法获取以Symbol方式定义的对象属性了么？非也。还是会有一些专门针对Symbol的API，比如：

```js
// 使用Object的API
Object.getOwnPropertySymbols(obj) // [Symbol(name)]

// 使用新增的反射API
Reflect.ownKeys(obj) // [Symbol(name), 'age', 'title']
```

#### 应用场景2：使用Symbol来替代常量

先来看一下下面的代码，是不是在你的代码里经常会出现？

```js
const TYPE_AUDIO = 'AUDIO'
const TYPE_VIDEO = 'VIDEO'
const TYPE_IMAGE = 'IMAGE'

function handleFileResource(resource) {
  switch(resource.type) {
    case TYPE_AUDIO:
      playAudio(resource)
      break
    case TYPE_VIDEO:
      playVideo(resource)
      break
    case TYPE_IMAGE:
      previewImage(resource)
      break
    default:
      throw new Error('Unknown type of resource')
  }
}
```

如上面的代码中那样，我们经常定义一组常量来代表一种业务逻辑下的几个不同类型，我们通常希望这几个常量之间是唯一的关系，为了保证这一点，我们需要为常量赋一个唯一的值（比如这里的'AUDIO'、'VIDEO'、 'IMAGE'），常量少的时候还算好，但是常量一多，你可能还得花点脑子好好为他们取个好点的名字。

现在有了`Symbol`，我们大可不必这么麻烦了：

```js
const TYPE_AUDIO = Symbol()
const TYPE_VIDEO = Symbol()
const TYPE_IMAGE = Symbol()
```

这样定义，直接就保证了三个常量的值是唯一的了！是不是挺方便的呢。

#### 应用场景3：使用Symbol定义类的私有属性/方法

我们知道在JavaScript中，是没有如Java等面向对象语言的访问控制关键字`private`的，类上所有定义的属性或方法都是可公开访问的。因此这对我们进行API的设计时造成了一些困扰。

而有了`Symbol`以及`模块化机制`，类的私有属性和方法才变成可能。例如：

- 在文件 a.js中

```js
const PASSWORD = Symbol()

class Login {
  constructor(username, password) {
    this.username = username
    this[PASSWORD] = password
  }

  checkPassword(pwd) {
      return this[PASSWORD] === pwd
  }
}

export default Login
```

- 在文件 b.js 中

```js
import Login from './a'

const login = new Login('admin', '123456')

login.checkPassword('123456')  // true

login.PASSWORD  // oh!no!
login[PASSWORD] // oh!no!
login["PASSWORD"] // oh!no!
```

由于Symbol常量`PASSWORD`被定义在a.js所在的模块中，外面的模块获取不到这个Symbol，也不可能再创建一个一模一样的Symbol出来（因为Symbol是唯一的），因此这个`PASSWORD`的Symbol只能被限制在a.js内部使用，所以使用它来定义的类属性是没有办法被模块外访问到的，达到了一个私有化的效果。

#### 注册和获取全局Symbol

通常情况下，我们在一个浏览器窗口中（window），使用`Symbol()`函数来定义和Symbol实例就足够了。但是，如果你的应用涉及到多个window（最典型的就是页面中使用了`<iframe>`），并需要这些window中使用的某些Symbol是同一个，那就不能使用`Symbol()`函数了，因为用它在不同window中创建的Symbol实例总是唯一的，而我们需要的是在所有这些window环境下保持一个共享的Symbol。这种情况下，我们就需要使用另一个API来创建或获取Symbol，那就是`Symbol.for()`，它可以注册或获取一个window间全局的Symbol实例：

```js
let gs1 = Symbol.for('global_symbol_1')  //注册一个全局Symbol
let gs2 = Symbol.for('global_symbol_1')  //获取全局Symbol

gs1 === gs2  // true
```


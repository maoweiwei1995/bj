网易雷火2019/5/28晚电面

CSS

## flex布局 有哪些属性   

## 不知道父元素宽度怎么实现四个长方体均等分布

 1.flex

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
    .out {
        display:flex;
        min-height: 100px;
        justify-content: center;
    }
    .item {
        width:100px;
        background-color: red;
        min-height:80px;
        margin:0 5px;
    }
    </style>
</head>
<body>
    <div class="out">
        <div class="item"></div>
        <div class="item"></div>
        <div class="item"></div>
        <div class="item"></div>
    </div>
</body>
</html>
```

2.grid

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
    .out {
        display:grid;
        min-height: 100px;
        grid-template-columns: repeat(4, 1fr);
        grid-column-gap: 10px;
    }
    .item {
        background-color: red;
        min-height:80px;
        
    }
    </style>
</head>
<body>
    <div class="out">
        <div class="item"></div>
        <div class="item"></div>
        <div class="item"></div>
        <div class="item"></div>
    </div>
</body>
</html>
```



## 怎么让一个元素宽度是另一个两倍 

1.flex

这个元素flex-grow:2

其他元素flex-grow:1

2.grid

1fr  2fr

## grid布局

## absolute和relative的区别

absolute定位是相对于父元素的绝对定位，且父元素必须有**position：absolute**或者**position：relative**，若其父元素没有，**则逐层网上寻找，直至浏览器窗口**

相对定位的最小化原则,避免最外层元素因位置变动而影响整个页面布局。 在父元素+一个position:relative

relative相对定位是相对于当前位置定位，**即相对于自己定位**。

js

## 原型是啥 

> js高级程序设计：
> 我们创建的每个函数对象都有一个prototype（原型）属性，指向一个对象，
> 这个对象包含可以由特定类型的所有实例共享的属性和方法

1. 所有的对象都有__proto__属性，该属性对应该对象的原型.

2. 所有的函数对象都有prototype属性，该属性的值会被赋值给该函数创建的对象的_proto_属性.

3. 所有的原型对象都有constructor属性，该属性对应创建所有指向该原型的实例的构造函数.

4. 函数对象和原型对象通过prototype和constructor属性进行相互关联.

   ## 原型链是啥

   就是利用原型让一个引用类型继承另一个引用类型的属性和方法。然后层层递进，就构成了实例与原型的链条，这就是原型链。

## get和post的区别  post会不会缓存？

**总结GET和POST的区别**

1. GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&相连，如EditPosts.aspx?name=test1&id=123456.  POST方法是把提交的数据放在HTTP包的Body中.

2. GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.

3. GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，**用户名和密码将出现在URL上，如果页面可以被缓存**或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。

4. GET请求会被浏览器主动cache，而POST不会，除非手动设置。

5. 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。

6. GET产生一个TCP数据包；POST产生两个TCP数据包。 

   长的说：

   对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；

   而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

## 还有哪些请求方式？

1、GET

**向特定的资源发出请求**。注意：GET方法不应当被用于产生“副作用”的操作中，例如在Web Application中，其中一个原因是GET可能会被网络蜘蛛等随意访问。Loadrunner中对应get请求函数：web_link和web_url

2、POST

**向指定资源提交数据**（例如**提交表单或者上传文件**）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 Loadrunner中对应POST请求函数：web_submit_data,web_submit_form

3、PUT

**向指定资源位置上传其最新内容**

4、DELETE

**请求服务器删除Request-URL所标识的资源**

5、HEAD

**和get请求类似 但是响应主体不会返回**。**可以用于获取响应首部字段**

这一方法可以再不必传输整个响应内容的情况下，就**可以获取包含在响应消息头中的元信息**。

6、OPTIONS

**返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性**

7、TRACE

**回显服务器收到的请求，主要用于测试或诊断**

8、CONNECT

HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。



cookie的设置   url一样会不会用缓存

跨域 方法

怎么让test.com访问163.com？好像有点问题

## 同步和异步任务

- 同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；
- 异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。

------

1. 所有**同步任务都在主线程上执行，形成一个执行栈**（execution context stack）。
2. **主线程之外，还存在一个"任务队列"**（task queue）。只要**异步任务有了运行结果，就在"任务队列"之中放置一个事件**。
3. 一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。**那些对应的异步任务，于是结束等待状态**，**进入执行栈，开始执行**。
4. 主线程不断重复上面的第三步。

## **异步的实现方式有哪些**

### 前言

JS需要异步处理的地方实在是比较多，比如定时器/ajax/io操作等等，在当今前端技术日新月异的情况下，异步编程成了核心技能之一，在这里我只是罗列一下几种我用过的异步编程方式并稍加对比。本次编写的代码全部在node 7+版本中运行

### 同步和异步

首先我们要弄清同步和异步到底是个什么玩意儿，其实我的理解就是他们对代码的“执行顺序”控制程度不一样。为什么这样说呢？因为同步在一段代码调用之后，是不管有没有结果返回的，立马就执行到下一步去了。而异步，是会等待那个调用的，直到返回了结果再往下执行。
举个例子：假设有个抢红包的调用,它是需要一段时间才能满足抢红包结束的

```js
var result = function(){
    if(抢红包结束) return 5
}
console.log(result())
```

如果是同步，这段代码就不管result的死活了直接往下走，输出undefined，如果写成异步风格的代码，那就不一样了。

### 回调函数

在前端的远古时代，回调是处理异步的不二选择，为什么，因为它的写法简单，没有多余的api。就拿刚刚那个抢红包的例子来说，我用一个定时器替代它：

```js
var result = function(){
    setTimeout(()=>{
        return 5;
    },1000)
}
console.log(result())
```

用回调函数处理怎么弄呢？很简单,让result的参数为一个回调函数就可以了，于是代码变成下面这样

```js
var result = function(callback){
    setTimeout(()=>{
        callback(5)
    },1000)
}
result(console.log)
```

现在我们用一个真实的io调用替代抢红包，新建一个numbers.txt，在里面写若干个红包金额,代码如下：

```js
const fs = require('fs');

const readFileAsArray = function (file, cb) {
    fs.readFile(file, (err, data) => {
        if (err) return cb(err);
        const lines = data.toString().trim().split('\n');
        cb(null, lines);
    })
}

readFileAsArray('./numbers.txt', (err, lines) => {
    if (err) throw err;
    const numbers = lines.map(Number);
    console.log(`分别抢到了${numbers}块红包`);
})
```

代码输出为:

```
>分别抢到了10,11,12,13,14,15块红包
```

从代码中我们可以看到，定义了一个readFileAsArray函数，传两个参：文件名和回调函数，然后调用这个函数，把回调函数写入第二个参数里，就可以控制代码执行顺序了。
不过，回调的缺点就是写多了，层层嵌套，又会造成回调地狱的坑爹情况，代码变得难以维护和阅读。所以我们需要更好的解决办法。

### Promise

借用ydjs的一句话：Promise实现了控制反转。什么意思呢？原来这个顺序的控制是在代码那边而不是程序员控制，现在有了Promise，控制权就由人来掌握了，通过一系列Promise的方法如then/catch/all/race等控制异步流程。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise文档</a>
还是刚刚那个抢红包的例子，这次用Promise来写就是这样的：

```js
const fs = require('fs');

const readFileAsArray = function (file) {
    return new Promise((resolve, reject) => {
        fs.readFile(file, (err, data) => {
            if (err) {
                reject(err);
            }
            const lines = data.toString().split('\n');
            resolve(lines);
        })
    })
}

readFileAsArray('./numbers.txt').then(
    lines => {
        const numbers = lines.map(Number);
        console.log(`分别抢到了${numbers}块红包`);
    }
).catch(error => console.error(error));
```

结果和使用回调函数一样，但是在这里已经把控制权交给了程序员，代码也变得更好理解。**虽然Promise有单值/不可取消等缺点**，不过在现在大部分的情况下实现异步还是够用的。想深入了解的朋友可以去看看《你不知道的JS》中卷第三章。

### await/async

Promise的api太多了，有没有简化的办法呢？答案是肯定有的，ES7推出了一个语法糖：await/async，它的内部封装了Promise和Generator的组合使用方式，至于Generator是什么，这里不再赘述，有兴趣的朋友们可以去自行研究。
于是，刚刚那段代码就变成了：

```js
const fs = require('fs');

const readFileAsArray = function (file) {
    return new Promise((resolve, reject) => {
        fs.readFile(file, (err, data) => {
            if (err) {
                reject(err);
            }
            const lines = data.toString().split('\n');
            resolve(lines);
        })
    })
}

async function result() {
    try {
        const lines = await readFileAsArray('./numbers.txt');
        const numbers = lines.map(Number);
        console.log(`分别抢到了${numbers}块红包`);
    } catch (err) {
        console.log("await出错！");        
        console.log(err);
    }
}

result();
```

这样做的结果是不是让代码可读性更高了！而且也屏蔽了Promise和Generator的细节。

### event

另一个实现异步的方式是event，回调(promise、await/async)和event的关系就像计划经济和市场经济一样，一个是人为的强制性的控制，一个是根据需求和供给这只看不见的手控制。
还是同一个例子，用event写就是这样：

```js
const EventEmitter = require('events');
const fs = require('fs');
class MyEventEmitter extends EventEmitter {
    executeAsy(asyncFunc, args) {
        this.emit("开始");
        console.time('执行耗时');
        asyncFunc(args, (err, data) => {
            if (err) return this.emit('error', err);
            this.emit('data', data);
            console.timeEnd('执行耗时');
            this.emit("结束");
        });
    }
}

const myEventEmitter = new MyEventEmitter();

myEventEmitter.on('开始', () => {
    console.log('开始执行了');
})
myEventEmitter.on('data', (data) => {
    console.log(`分别抢到了${data}块红包`);
})
myEventEmitter.on('结束', () => {
    console.log('结束执行了');
})
myEventEmitter.on('error', (err) => {
    console.error(err);
})

myEventEmitter.executeAsy(fs.readFile, './numbers.txt');
```

这种事件驱动非常灵活，也不刻意去控制代码的顺序，一旦有事件的供给(emit)，它就会立刻消费事件(on)，不过正是因为这样，它的缺点也很明显：让程序的执行流程很不清晰。

### event+promise+await/async

纯粹的计划经济也不好，纯粹的市场经济也不好。好的方式是什么？当然是结合起来啦！
所以就有了结合event和promise的写法:

```js
const EventEmitter = require('events');
const fs = require('fs');
class MyEventEmitter extends EventEmitter {
    async executeAsy(asyncFunc, args) {
        this.emit("开始");
        try {
            console.time('执行耗时');
            const data = await asyncFunc(args);
            this.emit('data', data);
            console.timeEnd('执行耗时');
            this.emit('结束');
        } catch (err) {
            console.log("出错了!");
            this.emit('error', err);
        }

    }
}

const readFileAsArray = function (file) {
    return new Promise((resolve, reject) => {
        fs.readFile(file, (err, data) => {
            if (err) {
                reject(err);
            }
            const lines = data.toString().split('\r\n');
            resolve(lines);
        })
    })
}
const myEventEmitter = new MyEventEmitter();

myEventEmitter.on('开始', () => {
    console.log('开始执行了');
})
myEventEmitter.on('data', (data) => {
    console.log(`分别抢到了${data}块红包`);
})
myEventEmitter.on('结束', () => {
    console.log('结束执行了');
})
myEventEmitter.on('error', (err) => {
    console.error(err);
})

myEventEmitter.executeAsy(readFileAsArray, './numbers.txt');
```

这种结合的方式基本上可以应付现今的异步场景了，缺点嘛。。。就是代码量比较多

### rxjs

js越发壮大，jser们终于站起来了，看着其他语言使用着rx这个强大的工具，我们怎么能少，一种大一统管理异步的方案：rxjs就这样来到了世上。
简单介绍下rxjs和异步的关系：它可以把数据转化成一股流，无论这个数据是同步得到的还是异步得到的，是单值还是多值。
比如用Rx.Observable.of来包装单值同步数据，
用Rx.Observable.of来包装单值同步数据，
用Rx.Observable.fromPromise来包装单值异步数据，
以及用Rx.Observable.fromEvent来包装多值异步数据：

```js
const fs = require('fs');
const Rx = require('rxjs');
const EventEmitter = require('events');

class MyEventEmitter extends EventEmitter {
    async executeAsy(asyncFunc, args) {
        this.emit("开始");
        try {
            console.time('执行耗时');
            const data = await asyncFunc(args);
            this.emit('data', data);
            console.timeEnd('执行耗时');
            this.emit('结束');
        } catch (err) {
            console.log("出错了!");
            this.emit('error', err);
        }

    }
}

const readFileAsArray = function (file) {
    return new Promise((resolve, reject) => {
        fs.readFile(file, (err, data) => {
            if (err) {
                reject(err);
            }
            const lines = data.toString().split('\r\n');
            resolve(lines);
        })
    })
}
const myEventEmitter = new MyEventEmitter();

myEventEmitter.executeAsy(readFileAsArray, './numbers.txt');

let dataObservable = Rx.Observable.fromEvent(myEventEmitter, 'data')

let subscription = dataObservable.subscribe((data) => {
    console.log(`分别抢到了${data}块红包`);
}, err => {
    console.error(err);
}, compelete => {
    console.info("compelete!");
})
```

rxjs还有很多重要的概念，比如生产者Observe和消费者Observable、推拉模型、各种方便的操作符和函数式编程等等

介绍一下 Promise 

Promise回顾
Promise对象是JavaScript ES6标准中一个重要的内容，它是为了异步而生的，相比于经典的回调函数写法，在处理大量异步任务时使用Promise链在可读性上会远远优于回调函数导致的回调地狱，本文建立在读者已经对Promise有所了解的情况下，如果你还不了解Promise，可以参考MDN上的这篇文章。

下面我们先来简要回顾一下Promise对象的性质，如果你已经足够熟悉，请前往下一节内容。

Promise有三种状态，如果用Promise()构造器创建一个Promise对象，当被创建时，它的状态是pending，如果一个Promise对象的resolve方法被调用，它的状态会变成fulfilled，而如果一个Promise对象的reject方法被调用，它的状态会变成rejected。此外，还有两种初始化Promise对象的方法，分别是Promise.resolve方法和Promise.reject方法，前者会直接返回一个状态为fulfilled的Promise对象而后者会直接返回一个状态为rejected的Promise对象。

在一个Promise链中，如果一个Promise状态变成了fulfilled，它会自动在Promise链中向下寻找，直到发现一个then方法，并执行其中的第一个参数函数，而如果一个Promise的状态变成了rejected，它会在Promise链中向下寻找，直到发现一个带有两个参数的then方法并执行它的第二个参数函数或发现一个catch方法并执行它的参数函数。

要知道，Promise.prototype.then和Promise.prototype.catch都会返回一个Promise对象，这是Promise链能生效的关键，这篇文章讨论的重点就是这两个方法的返回值。

注意：为了增强可读性，本文中涉及到Promise.prototype.then都只传入一个参数，作为fulfilled状态的回调函数，rejected状态的回调函数在Promise.prototype.catch中定义。

Promise回调函数返回非Promise值
当一个Promise.prototype.then方法被调用时，且在回调函数中返回的值是一个非Promise对象时，它会生成一个状态为fulfilled的新的Promise对象，并把该返回值传入下一个回调函数，看下面这个例子：

```javascript
Promise.resolve().then(function() {
  return 'Hello World';
})
.then(function(value) {
  console.log(`fulfilled: ${value}`); // 'fulfilled: Hello World'
})
.catch(function(value) {
  console.log(`rejected: ${value}`);
});
```

我们先用Promise.resolve生成了一个fulfilled状态的Promise对象以便调用then方法，在它的回调函数中我们返回了一个字符串Hello World，可以看到Promise链中第二个then方法的回调函数被调用，打印出了fulfilled: Hello World，说明前一个回调函数的返回值被传入，且在Promise链的上一环节返回的新Promise状态为fulfilled。

当一个Promise.prototype.catch方法被调用，且在回调函数中返回的值是一个非Promise对象，它仍然会生成一个状态为fulfilled的新的Promise对象，并把该返回值传入下一个回调函数，相当于错误已经被捕获，看下面这个例子：

```javascript
Promise.reject().catch(function() {
  return 'Hello World';
})
.then(function(value) {
  console.log(`fulfilled: ${value}`); // 'fulfilled: Hello World'
})
.catch(function(value) {
  console.log(`rejected: ${value}`);
})
```

我们先用Promise.reject生成了一个rejected状态的Promise对象，这时第一个catch方法触发，在它的回调函数里返回了字符串Hello World，此后第一个then方法触发，打印出了fulfilled: Hello World，说明前一个回调函数的返回值被传入，且在Promise链的上一环节返回的新Promise状态为fulfilled。

你可以动手试试上面的例子，自己尝试着修改一些代码并查看返回值，有助于对这一节的内容有更深的理解。

Promise回调函数返回Promise对象
如果Promise的回调函数中返回的是Promise，那么无论触发的是Promise链中的then方法还是catch方法，新生成的Promise对象的状态都直接取决于回调函数中返回的Promise对象的状态，传进下一个回调函数的值也取决于这个被返回的Promise对象，让我们看下面几个例子：

```javascript
Promise.resolve().then(function() {
  return Promise.resolve('Hello World');
})
.then(function(value) {
  console.log(`fulfilled: ${value}`); // 'fulfilled: Hello World'
})
.catch(function(value) {
  console.log(`rejected: ${value}`);
});
```



```javascript
Promise.resolve().then(function() {
  return Promise.reject('Hello World');
})
.then(function(value) {
  console.log(`fulfilled: ${value}`);
})
.catch(function(value) {
  console.log(`rejected: ${value}`); // 'rejected: Hello World'
});
```

```javascript
Promise.reject().catch(function() {
  return Promise.resolve('Hello World');
})
.then(function(value) {
  console.log(`fulfilled: ${value}`); // 'fulfilled: Hello World'
})
.catch(function(value) {
  console.log(`rejected: ${value}`);
});
```







```javascript
Promise.reject().catch(function() {
  return Promise.reject('Hello World');
})
.then(function(value) {
  console.log(`fulfilled: ${value}`);
})
.catch(function(value) {
  console.log(`rejected: ${value}`); // 'rejected: Hello World'
});
```



你可以动手试试上面的例子来更深刻地感受一下返回Promise对象与返回其他值时的不同。

通过这几个例子可以看到，如果回调函数中返回Promise对象，无论是then方法还是catch方法生成的Promise对象都直接取决于回调函数中的这个Promise对象。

Promise回调函数中抛出错误
如果Promise的回调函数中抛出了一个错误，则会生成一个状态为rejected的Promise，并将这个错误作为参数传给Promise链的下一个回调函数，看下面两个例子：

```javascript
Promise.resolve().then(function() {
  throw new Error('Oops!');
})
.then(function(value) {
  console.log('fulfilled');
  console.log(value.message);
})
.catch(function(value) {
  console.log('rejected'); // 'rejected'
  console.log(value.message); // 'Oops!'
});
```





```javascript
Promise.reject().catch(function() {
  throw new Error('Oops!');
})
.then(function(value) {
  console.log('fulfilled');
  console.log(value.message);
})
.catch(function(value) {
  console.log('rejected'); // 'rejected'
  console.log(value.message); // 'Oops!'
})
```



你可以动手试试来感受一下这种情况下抛出错误对生成的Promise对象的影响。

可以看到，这种情况下catch的回调函数被执行，说明抛出错误后，返回的Promise状态是rejected，并且传入Promise链下一环节的值是这个错误对象。

总结
当Promise的回调函数返回非Promise对象的值时，then和catch都生成一个状态为fulfilled的Promise对象，并把该返回值传入Promise链的下一环节。
当Promise的回调函数返回值为Promise对象时，生成的Promise对象的状态由被返回的Promise对象决定，传入Promise链下一环节的值也由这个被返回的Promise决定。

当Promise的回调函数中抛出错误时，then和catch都生成一个状态为rejected的Promise对象，并把抛出的错误对象传入Promise链的下一环节。

## vue

生命周期 数据什么时候挂载

`　　beforecreate`：el 和 data 并未初始化 

`　　created`:完成了 **data 数据的初始化，el没有**

`　　beforeMount`：

`　　mounted` ：完成挂载　　完成了 el

beforeupdate  updated；

beforedestroyed destroyed

1. 在create函数中能不能用this.访问属性
   可以访问
2. $el什么时候挂载到实例，又或者什么时候可以获取组件的dom元素
   在mounted函数之后都可以

原理